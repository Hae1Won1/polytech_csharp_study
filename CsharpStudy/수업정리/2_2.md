.

📌 C# 문자열 처리 & 메모리 동작 정리
1. 문자열 처리 메서드

Substring
문자열 일부 추출

string part = s1.Substring(0, 3); // 앞에서 3글자


Replace
특정 문자열 치환

string changed = s1.Replace("LL", "XX");


Split
구분자로 분리

string[] splitNumbers = s1.Split(',');


ToLower / ToUpper
소문자/대문자로 변환

Length
문자열 길이 반환

string.IsNullOrEmpty(s)

s가 null 또는 빈 문자열("")이면 true

string.IsNullOrWhiteSpace(s)

s가 null, 빈 문자열, 또는 공백 문자로만 이루어져 있으면 true

2. 메모리 주소 상의 string 동작

string은 참조형(Reference Type) & 불변(Immutable)

문자열 리터럴은 힙(Heap) 에 저장되고, 변수에는 그 주소(참조) 가 저장됨

문자열 연산 (+)

+ 연산으로 문자열을 더하면:

힙에 새로운 string 인스턴스 생성

변수는 새 인스턴스를 가리킴

기존 인스턴스는 참조가 끊어지면 GC 대상이 됨

3. 성능 최적화: StringBuilder

StringBuilder는 가변 객체

내부적으로 char[] 버퍼를 관리 → 문자열 연산 시 버퍼를 수정

반복적인 문자열 연결 시 string보다 훨씬 빠름

4. 값 형식 vs 참조 형식

숫자(int, double 등) → 값 형식(Value Type)

스택(Stack)에 값이 직접 저장됨

재할당 시 기존 공간에 값만 교체

문자열(string) → 참조 형식(Reference Type)

스택에는 주소(참조)만 저장

실제 문자열은 힙에 존재

5. 문자열 interning (string pool)

같은 문자열 리터럴은 string pool에 저장되어 재사용됨

따라서 "hello"와 "hel" + "lo" 는 같은 인스턴스를 참조 → 동일한 GetHashCode 반환

6. new string() 의 차이

new string("hello") 처럼 new 키워드를 쓰면
→ string pool을 무시하고 무조건 새로운 인스턴스 생성

값은 같아도 참조 주소는 다름

👉 정리하면:

문자열은 불변 참조형 → 연산 시마다 새 인스턴스

문자열 연산이 많으면 StringBuilder 사용 권장

숫자는 값 형식이라 스택에서 값만 교체

문자열 리터럴은 pool 재사용, new string()은 무조건 새 인스턴스